class Inner(ConfigSpec):
	t1 = Something()
	t2 = Something()
	t3 = Something()


class Outer(ConfigSpec):
	o1 = MultiTask("outer1", ConfigClassTask("inners", Inner), some_component_list)
	o2 = MultiTask("outer2", Something(), some_component_list)
	
	#how to (detectably) note that you want a o2 task to start as soon
	#as an o1 config class task completes (instead of waiting for all
	#of them to complete before doing o2)?
	
	#we might need to write o1 as:
	o1 = MultiTask("outer1", ConfigClassTask("inners", Inner), some_component_list, no_rendezvous=True)
	#that would make the exit_nodes() method return all of the exit nodes of each
	#instance of ConfigClassTask, instead of just the rendevous task for the MultiTask

	#how do we note that we want to match up each of these to the instances of o2 according to the
	#namespace component?

	#seems to error prone to just find a new binary operator and hope both operands have the same component
	#list, like so:
	with_dependencies( o1 - o2 )

	#maybe a new wrapper task that takes other MultiTasks and drives them from a common component list?
	o1 = MultiTask("outer1", ConfigClassTask("inners", Inner), no_rendezvous=True)
	o2 = MultiTask("outer2", Something())
	with_dependencies( TaskMatcher(some_component_list, o1, o2) )

	#or maybe, the right thing to do is to expand on the MultiTask wrapper and allow an abritrary number
	#of template objects to be supplied; if used this way, then the default action would be to
	#pipeline the template tasks from the same host; something like this:

	o1 = MultiTask("outer1", some_component_list, ConfigClassTask("inners", Inner), Something())

	#In this use, for each component in some_component_list, an instance of ConfigClassTask and Something
	#are created, and the Something instance is made a dependent of the ConfigClassTask instance.
	#this way, the work for each component can proceed at the fastest pace possible, and delays on
	#one component won't adversely effect the overall progress being made for all components. However,
	#the overall MultiTask wrapper doesn't complete until all contained tasks are complete

	#I have a mild issue in that there are implicit dependencies established betweeen the instances
	#of the templates, in contrast to the explicit dependency expressions used in the
	#with_dependencies() function. However, you could argue that these higher-order wrappers are there
	#to provide some of this machinery anyway, and so this is in keeping with both the original
	#MultiTask and ConfigClassTask wrappers.

	#it may be worthwhile to actually create another class named MultiTaskPipeline instead of
	#changing MultiTask. So the above would be re-written like so:

	o1 = MultiTaskPipeline("outer1", some_component_list, ConfigClassTask("inners", Inner), Something())

	#we would then change MultiTask to be a derived class of MultiTaskPipeline that provides the same
	#interface as currently but really is just a degenerate case of MultiTaskPipeline
	
